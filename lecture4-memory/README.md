## 文字列
- `string s = "HI!";`と宣言された変数は一文字ずつメモリに格納される。
- 変数`s`には最初の文字のアドレスをもつ単なるポインタである。

## ポインタ演算
以下のプログラムを実行すると、

```c
#include <stdio.h>

int main(void)
{
    char *s = "HI!";
    printf("%c\n", *s);
    printf("%c\n", *(s+1));
    printf("%c\n", *(s+2));
}
```

次のように出力される。

```sh
H
I
!
```

`printf("%c\n", *s);`の行では、sには`"HI!"`の最初の文字のアドレスが格納されているので当然`H`が出力される。

- 次の`*(s+1)`は`s`の1バイト上位のアドレス、つまり次の文字を持つメモリ内の場所を参照する。
- `s[1]`は`*(s+1)`のシンタックスシュガー。
- `*(s+10000)`のようにメモリ内のアクセスすべきではないアドレスにアクセスすることもできてしまう。

## ゴミの値

次のプログラムを実行すると、`1 34258944 1`や`1 38551552 1`のような値が出力される。
これはゴミの値と呼ばれていて、配列の初期化を行わないとこれまでコンピュータで実行されていたプログラムからのゴミの値やメモリ内の未知の値が出力される。
当然segfaultを引き起こす可能性がある。

```c
#include <stdio.h>

int main() {
  int scores[3];
  for (int i = 0; i < 3; i++) {
    printf("%i\n", scores[i]);
  }
}

```

## 課題でハマったところ
- 整数のオーバーフロー
    - 今考えると当然だけど`uint8_t`同士の足し算の結果を`uint8_t`に代入するとオーバーフローする可能性がある。
    - 同様に負を取りうる値なのに`uint8_t`を使っていたりすると同様にオーバーフローする可能性がある。
